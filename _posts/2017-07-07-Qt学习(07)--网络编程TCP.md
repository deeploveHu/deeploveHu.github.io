---
layout: post
title:  "Qt学习(07)--网络编程TCP"
categories: Qt
tags:  Qt
author: bloglink
---

* content
{:toc}

Qt 提供了 QTcpSocket 类来实现tcp通信，下面是我在 QTcpSocket 使用过程中的一些心得。



## 一 连接

    tcp = new QTcpSocket（this);
    tcp->connectToHost("xxx.xxx.xxx.xxx", 1234);

## 二 发送数据

    void writeBlock(QByteArray msg) {
        QByteArray block;  //用于暂存要发送的数据  
        QDataStream out(&block,QIODevice::ReadWrite);  //使用数据流写入数据  
        out.setVersion(QDataStream::Qt_4_8);  //设置数据流的版本，客户端和服务器端使用的版本要相同  
        out << (quint64) 0;  //设置发送长度初始值为0  
        out << msg;  //设置发送内容  
        out.device()->seek(0);  //回到字节流起始位置  
        out << (quint64) (block.size()-sizeof(quint64)); //重置字节流长度   
        tcp->write(block);  //往套接字缓存中写入数据，并发送
    }

## 三 发送文件

发送文件头

    file = new QFile(name);
    if (!file->open(QFile::ReadOnly)) {
        qDebug()  <<  file->errorString();
        return;
    }
    LoadSize = 1024*4;//每次发送4k
    writeBlock(name);
    BytesToWrite = file->size();
    BytesWritten = 0;

在bytesWritten(qint64)槽函数中发送文件内容

    if (BytesToWrite == 0)
        return;
    BytesWritten += numBytes;
    writeBlock(file->read(LoadSize));
    BytesToWrite -= qMin(BytesToWrite, LoadSize);
    if (BytesToWrite == 0)
        file->close();

## 四 读取数据

    QByteArray msg;
    QDataStream in(tcp);
    in.setVersion(QDataStream::Qt_4_8);
    while (1) {
        if (BlockSize == 0) {
            if (tcp->bytesAvailable() < qint64(sizeof(qint64)))
                return;
            in >> BlockSize;
        }
        if (tcp->bytesAvailable() < BlockSize)
            return;
        in >> msg;
        qDebug() << msg;
        BlockSize = 0;
    }

## 四 结语

通过写入字节流长度可以有效避免 TCP 粘包和拆包问题，在实际应用中也得到了很好的验证。对于文件的发送，由于网络环境十分复杂，实际使用中经常有掉线等现象，发送文件时可定义每次发送的数据包大小，以便在客户端实现断点续传等功能。
